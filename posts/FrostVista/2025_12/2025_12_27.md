---
title: Implementation of UART interrupts
date  : 2025-12-27
time  : 10:51:08
archive: FrostVista
categories: [OS, Kernel, C/C++]
summary: Implementing UART TX interrupts with buffer management, LSR register handling, and debugging ebreak interrupt issues.
---


{
Yesterday, I implemented the UART RX interrupt method, but I didn't document it at the time. Today, I plan to write about the TX interrupt method for reference, since TX is still the most frequently used function at this stage.

The implementation of TX interrupts differs slightly from that of RX interrupts. Before sending a message, the TX buffer should be filled as much as possible to transmit in a single batch, thereby avoiding excessive interrupts that could degrade performance.

It is also important to note that in UART, the LSR bit indicates whether the transmitter is idle, not whether data is ready for reception.

It's important to note that TX transmits data after receiving it--this is a key point to remember and should not be confused with RX.

So, the difference between RX and TX is that TX writes data into the UART buffer--which is obvious, of course.

Therefore, what matters to us is whether the UART transmit buffer has free space available for sending data, as indicated by the LSR_TX_IDLE register. When TX interrupts are enabled, if space is available, TX_IDLE will trigger an interrupt.

Therefore, we need to create a buffer for TX to store the data we want to send to the UART. Essentially, we stuff the string into this buffer and then transmit the data to the UART.

The uart_put function needs to be modified to write data into tx_buf and enable the TX interrupt based on whether data is present in tx_buf.

Another issue encountered was that even when only enabling TX interrupt without writing data first, problems still occurred.{

The problem I encountered is that after triggering the ebreak interrupt, all subsequent outputs cease.

I suspect the primary reason is that the IDLE interrupt isn't triggered by a sustained logic level. Therefore, it's necessary to write a small amount of data first to ensure subsequent IDLE interrupts continue to fire.

I don't think it's because sstatus.sie was turned off after entering the trap handler.
}


}
