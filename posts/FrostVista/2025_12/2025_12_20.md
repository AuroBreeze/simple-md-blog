---
title: PTE's Confusion Issues and Problem Tracking and Handling
date  : 2025-12-20
time  : 16:38:38
archive: FrostVista
categories: [OS, Kernel, C/C++]
summary: Addressing chicken-and-egg problems in high-address mapping, PTE allocation misconceptions, and implementing ekalloc for boot-time memory management.
---


{
When extracting kernel mapping from identity mapping to high-address mapping, we encountered the chicken-and-egg problem.

The current boot process uses the "-bios none" options. Upon entering the kernel, it  operates in M mode. It must first switch from M mode to S mode before enabling paging. However, before enabling paging, it requires functions like "kalloc" to acquire the page table and other essential features, as well as perform necessary allocations within the walk structure.

However, at one point, my mind seemed a bit confused, thinking that the size of the PTE matched the size of the mapped object.

In actual page tables, multiple kalloc paging operations only occur during system startup when PTEs are sparse--specifically when population the previously mentioned three-dimensional array. This array requires 512GB to fill, yet our system currently uses only 128MB of memory. Moreover, kalloc is only invoked for mapping when absolutely necessary, and each allocated page can store more than one PTE -- up to 512 PTEs.

So, i mistakkenly believed that all memory had to be allocated before enabling paging, but i was wrong.

Howerver, i did learn two lessons from this incident.

I need to develop a more robust logging system to track functions that may return erronrous data--such as waring-level 'return 0' errors that requires logging--and implement a more display remaining memory, permission bits, physical addresses, virtual addresses, and other relevant details.
}

{
I removed all the mechanisms I worte yesterday for enabling paging, such as ekalloc, which were separated out. As ai mentioned, this approach is cumbersome and unnecessary. I then implement a simple ekalloc function that directly points to the _kernel_end address. It method is convenient and avoids the need to set a fixed number of pages to allocate before paging is enabled. It also eliminates the requirement to maintain a second, similar system within kalloc.c
}

{
To achieve high-address mapping, it is necessary to jump the address beyond the high-address boundary and also pull the SP address into the high-address range.

When implementing high-address jumps, since the page table has already been written and the SATP register set, a simple inline assembly can used to directly perform the address jump and set the SP flag.

However, it should be noted that _kernel_end may be elevated due to high-address mapping;
}
