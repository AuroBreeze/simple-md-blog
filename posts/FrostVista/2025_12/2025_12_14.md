---
title: Privilege Level Switching and Simple Trap Implementation
date  : 2025-12-14
time  : 09:23:28
archive: FrostVista
categories: [OS, Kernel, C/C++, devlog]
summary: Exploring RISC-V privilege architecture for Sv39 paging, PMP configuration, and trap delegation from M-mode to S-mode.
---

{
today, i plan to review the RISC-V privilege architecture manual to see how to implement Sv39  paging.

the core section is introduced in Chapter 12.1.11 and subsequent chapters on sv39 pagination.

the focus should not be solely on pagination issues, but also on privilege level switching.

the privilege level is still in M mode, it needs to be switched to S mode.

however, changes to the privilege levels are scattered throughout the privilege architecture manual without detailed explanation.

it was discovered that the sections on the traps and mastatus describe how to switch privilege levels.
}

{
The Physical Memory Protection chapter explains the usage of PMP, which provides instruction fetching and data access for S mode. This requires configuring the relevant pmpaddr and pmpcfg parameters, as well as carefully reviewing the manual's specifications--such as configuration of the A field within PMP.

configuer PMP. PMP will perform checks when MPP is set to S or U in mstatus.
In PMP, the three permission bits R/X/W must be set 

Here we intend to configuer addr0 and cfg0, setting their usable range with an upper bound of pmpaddr0 and a lower bound of 0.
Below is the original text from the manual:
If PMP entry 0’s A field is set to TOR, zero is used for the lower bound, and so it matches any
address y<pmpaddr0
end
}

{
Transitioning from M mode to S mode is a challenging part. The relevant information is scattered across multiple places in the manual (trap return, trap delegation, virtual memory).

One key issue is trap delegation. This requires configuring medeleg and mideleg in M mode (before mret). If a trap is delegated to S mode, then the CPU will enter the S-mode trap path and report the trap information in scause, sepc, stval. Otherwise, the trap is handled in M mode and the information appears in mcause, mepc, mtval.

Section 3.1.8 explains the delegation mechanism. For which bit corresponds to which exception/interrupt cause, you need to consult the mcause/scause cause codes table (e.g., the later chapters that list exception/interrupt values).
}


{
This is not just “searching for information”. To implement a simple trap, the handler must be reachable through stvec.

The stvec register changes the PC directly when a trap occurs. At that moment, the current context has not been saved, and registers may still be in use. Therefore, an assembly entry (like kernelvec.S) is commonly used as a small trampoline to save minimal state (or at least avoid clobbering registers) and then call the C trap handler
}

{
Current boot flow:

Boot in M mode and establish a minimal C environment (stack, clear BSS).

In M mode, configure PMP, set medeleg/mideleg, prepare mstatus.MPP=S and mepc=s_mode_entry, then execute mret.

In S mode entry, set stvec early and then jump into main/kernel_main.

Later, when page tables are ready, enable paging (satp + sfence.vma).

}


{
Implementing a returnable trap is also quite challenging. It requires consulting the RISC-V ABI manual to identify all general-purpose registers and saving them all during the trap.

I hadn't realized the architecture had so many manuals—privileged and non-privileged manuals, ABI C, assembly, embedded, ELF manuals, and many more.

Currently, only a simple return has been implemented, and there are pitfalls regarding command length that require attention during the return process.

I'm not really in the mood to write today. I just want to go home, grab some snacks, and relax.

The information in this basic manual is fragmented and scattered.
}
