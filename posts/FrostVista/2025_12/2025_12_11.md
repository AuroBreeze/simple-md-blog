---
title: devlog 12-11
date  : 2025-12-11
time  : 08:05:05
archive: FrostVista
categories: [OS, Kernel, C/C++]
summary: 
---

{
i plan to set up the directory structure to make it easier to maintain.

there was a minor hiccup where i couldn't locate the header file, but adding '-Iinclude' to both the .clangd and makefile files resolved it perfectly.

i'm actually quite glad i wrote a Quick-C C/C++ plugin that generates complie_commands.json files effectively, allowing me to quickly jump to the implementation sections of my functions.
}

{
To achieve the functionality of encapsulating printf, we need to emulate printf.

the most important aspect of printf is handing the % symbol.

However, the first argument of printf is essentially a string. it reads character by character and then processes it. when it encouters a %

of course, you must handle output boundaries carefully, such as end markers , %s, %d, %p, %c,and so on.

regarding the usage of ... in C/C++, this is something need to study.
}

{
during the compilation process, i encountered an LD issue that prevent the UART from outputing normally.

the likely cause is that the position of the .data segment has not been handle proprely, or the .bss segment has not set up correctly.

it's really helpful to study the usage of LD specifically. i spent some thing tonight looking into how to use LD.
}

Handling of Certain Questions in LD : {
First is the kernel stack. What is the purpose of the kernel stack:
{
its primary function is to store variables and other elements required in assembly code.

No room to store this stuff, but it'll explode, haha.

Note, it's important to note that the stack growth in RISCV is downward.
}
The second question concerns the purpose of defining LENGTH.Dose setting LENGTH=128M mean only 128M of memory is allocated? :
{
of course, that's not the case. This feature allows LD to store the file's .text .data .bss sections and determine their locations preventing you from linking the kernel to a non-existent address.
}

How are .text .data .bss sections laid out? Are they contiguous? : 
{
it is continuous, thought there's a slight gap when aligning. Logically, it is continuous.
}
Then why is there a distinction between 4-byte and 16-byte alignment? : 
{
This is entirely a matter of “designer's choice,” with no absolute standard. It relates to factors such as instruction alignment and data alignment.
}
}

{
My personal idea is to obtain the array's address at the end of the LD phase to avoid issues stemming from the kernel stack, such as errors caused by improperly clearing the kernel stack.
}

{
functions you use all the time--it's only when you actually implement them yourself that you realize how many details you need to pay attention to.

the memmove function must handle three scenarios involving two addresses, where size_t is an unsigned integer, and so on.
}
